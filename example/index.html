<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="../node_modules/dat.gui/build/dat.gui.min.js"></script>
    <link rel="stylesheet" type="text/css" href="../node_modules/dat.gui/build/dat.gui.css">

    <style type="text/css">
        html, body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <script type="module">
        import * as THREE from '../node_modules/three/build/three.module.js'
        import Stats from '../node_modules/stats.js/src/Stats.js'
        import '../index.js'
    
        const bgColor = 0x263238 / 2;

        // renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(bgColor, 1);
        document.body.appendChild(renderer.domElement);

        // scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x263238 / 2, 20, 60)
        const light = new THREE.DirectionalLight(0xffffff, 0.5);
        light.position.set(1,1,1);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4))

        // geometry setup
        const radius = 10;
        const tube = 3;
        const tubularSegments = 400;
        const radialSegments = 100;
        const geometry = new THREE.TorusKnotGeometry(radius, tube, tubularSegments, radialSegments);
        const material = new THREE.MeshLambertMaterial({ color: 0xE91E63 });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
        camera.position.z = 40;
        camera.far = 100;
        camera.updateProjectionMatrix()

        // stats setup
        const stats = new Stats();
        document.body.appendChild(stats.dom);

        // Create ray casters in the scene
        const rayCasterObjects = [];
        const raycaster = new THREE.Raycaster();
        const sphere = new THREE.SphereGeometry(.25, 20, 20);
        const cylinder = new THREE.CylinderGeometry(0.02, 0.02);
        const pointDist = 25;

        const options = {
            raycasters: {
                count: 25,
                speed: 1,
            },

            mesh: {
                useBoundsTree: true,
                speed: 1
            }
        }
        
        const addRaycaster = () => {
            // Objects
            const obj = new THREE.Object3D();
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const origMesh = new THREE.Mesh(sphere, material);
            const hitMesh = new THREE.Mesh(sphere, material);
            hitMesh.scale.multiplyScalar(0.5);

            const cylinderMesh = new THREE.Mesh(cylinder, new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.25 }));

            // Init the rotation root
            obj.add(cylinderMesh);
            obj.add(origMesh);
            obj.add(hitMesh);
            scene.add(obj);

            // set transforms
            origMesh.position.set(pointDist, 0, 0);
            obj.rotation.x = Math.random() * 10;
            obj.rotation.y = Math.random() * 10;

            // reusable vectors
            const origvec = new THREE.Vector3();
            const dirvec = new THREE.Vector3();
            const xdir = (Math.random() - 0.5);
            const ydir = (Math.random() - 0.5);
            rayCasterObjects.push({
                update: () => {
                    obj.rotation.x += xdir * 0.01 * options.raycasters.speed;
                    obj.rotation.y += ydir * 0.01 * options.raycasters.speed;

                    origMesh.updateMatrixWorld();
                    origvec.setFromMatrixPosition(origMesh.matrixWorld);
                    dirvec.copy(origvec).multiplyScalar(-1).normalize();

                    raycaster.set(origvec, dirvec);
                    const res = raycaster.intersectObject(mesh, true);
                    const length = res.length ? res[0].distance : 1000;
                    
                    hitMesh.position.set(pointDist - length, 0, 0);
                    
                    cylinderMesh.position.set(pointDist - (length / 2), 0, 0);
                    cylinderMesh.scale.set(1, length, 1);

                    cylinderMesh.rotation.z = Math.PI / 2;
                },

                remove: () => {
                    scene.remove(obj);
                }
            });
        }

        const updateFromOptions = () => {
            while (rayCasterObjects.length > options.raycasters.count) rayCasterObjects.pop().remove();
            while (rayCasterObjects.length < options.raycasters.count) addRaycaster();

            if (!options.mesh.useBoundsTree && mesh.geometry.boundsTree) mesh.geometry.disposeBoundsTree();
            if (options.mesh.useBoundsTree && !mesh.geometry.boundsTree) {
                console.time('computing bounds tree');
                mesh.geometry.computeBoundsTree();
                console.timeEnd('computing bounds tree');
            }
        }

        const render = () => {
            stats.begin();
            mesh.rotation.x += 0.01 * options.mesh.speed;
            mesh.rotation.y += 0.05 * options.mesh.speed;
            mesh.updateMatrixWorld();

            rayCasterObjects.forEach(f => f.update());

            renderer.render(scene, camera);
            stats.end();
            
            requestAnimationFrame(render);
        };

        // Run
        const gui = new dat.GUI();
        const rcfolder = gui.addFolder('Raycasters');
        rcfolder.add(options.raycasters, 'count').min(1).max(200).onChange(() => updateFromOptions());
        rcfolder.add(options.raycasters, 'speed').min(0).max(20);
        rcfolder.open();

        const meshfolder = gui.addFolder('Mesh');
        meshfolder.add(options.mesh, 'useBoundsTree').onChange(() => updateFromOptions());
        meshfolder.add(options.mesh, 'speed').min(0).max(20);
        meshfolder.open();

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        updateFromOptions();
        render();
    </script>
</body>
</html>